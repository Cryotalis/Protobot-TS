export const heroEmotes: {[char: string]: string} = {
    'All': '**All**',
    'Monk': '<:monk:250374207194529812>',
    'Apprentice': '<:apprentice:250374207651708928>',
    'Huntress': '<:huntress:250374208800948225>',
    'Squire': '<:squire:250374210352840704>',
    'Ev2': '<:seriesEV:250374210113765376>',
    'Lavamancer': '<:lavamancer:250374207517491200>',
    'Abyss Lord': '<:AbyssLord:250374207156912128>',
    'Adept': '<:adept:350402392178556948>',
    'Dryad': '<:dryad:345156191967641600>',
    'Initiate': '<:initiate:327210374581714964>',
    'Gunwitch': '<:gunwitch:250374210382200832>',
    'Barbarian': '<:barbarian:421073360584310785>',
    'Mystic': '<:mystic:250374210562555904>',
    'Mercenary': '<:Mercenary:908430318845956136>',
    'Countess': '<:Countess:981719805784629308>',
}

export let timeZoneOffsets = [
    { name: 'A', offset: 'UTC +1' },
    { name: 'ACDT', offset: 'UTC +10:30' },
    { name: 'ACST', offset: 'UTC +9:30' },
    { name: 'ACT', offset: 'UTC -5' },
    { name: 'ACT', offset: 'UTC +9:30' },
    { name: 'ACWST', offset: 'UTC +8:45' },
    { name: 'ADT', offset: 'UTC +4' },
    { name: 'ADT', offset: 'UTC -3' },
    { name: 'AEDT', offset: 'UTC +11' },
    { name: 'AEST', offset: 'UTC +10' },
    { name: 'AET', offset: 'UTC +10:00' },
    { name: 'AFT', offset: 'UTC +4:30' },
    { name: 'AKDT', offset: 'UTC -8' },
    { name: 'AKST', offset: 'UTC -9' },
    { name: 'ALMT', offset: 'UTC +6' },
    { name: 'AMST', offset: 'UTC -3' },
    { name: 'AMST', offset: 'UTC +5' },
    { name: 'AMT', offset: 'UTC -4' },
    { name: 'AMT', offset: 'UTC +4' },
    { name: 'ANAST', offset: 'UTC +12' },
    { name: 'ANAT', offset: 'UTC +12' },
    { name: 'AQTT', offset: 'UTC +5' },
    { name: 'ART', offset: 'UTC -3' },
    { name: 'AST', offset: 'UTC +3' },
    { name: 'AST', offset: 'UTC -4' },
    { name: 'AT', offset: 'UTC -4:00' },
    { name: 'AWDT', offset: 'UTC +9' },
    { name: 'AWST', offset: 'UTC +8' },
    { name: 'AZOST', offset: 'UTC +0' },
    { name: 'AZOT', offset: 'UTC -1' },
    { name: 'AZST', offset: 'UTC +5' },
    { name: 'AZT', offset: 'UTC +4' },
    { name: 'AoE', offset: 'UTC -12' },
    { name: 'B', offset: 'UTC +2' },
    { name: 'BNT', offset: 'UTC +8' },
    { name: 'BOT', offset: 'UTC -4' },
    { name: 'BRST', offset: 'UTC -2' },
    { name: 'BRT', offset: 'UTC -3' },
    { name: 'BST', offset: 'UTC +1' },
    { name: 'BTT', offset: 'UTC +6' },
    { name: 'C', offset: 'UTC +3' },
    { name: 'CAST', offset: 'UTC +8' },
    { name: 'CAT', offset: 'UTC +2' },
    { name: 'CCT', offset: 'UTC +6:30' },
    { name: 'CDT', offset: 'UTC -5' },
    { name: 'CDT', offset: 'UTC -4' },
    { name: 'CEST', offset: 'UTC +2' },
    { name: 'CET', offset: 'UTC +1' },
    { name: 'CHADT', offset: 'UTC +13:45' },
    { name: 'CHAST', offset: 'UTC +12:45' },
    { name: 'CHOST', offset: 'UTC +9' },
    { name: 'CHOT', offset: 'UTC +8' },
    { name: 'CHUT', offset: 'UTC +10' },
    { name: 'CIDST', offset: 'UTC -4' },
    { name: 'CIST', offset: 'UTC -5' },
    { name: 'CKT', offset: 'UTC -10' },
    { name: 'CLST', offset: 'UTC -3' },
    { name: 'CLT', offset: 'UTC -4' },
    { name: 'COT', offset: 'UTC -5' },
    { name: 'CST', offset: 'UTC -6' },
    { name: 'CST', offset: 'UTC +8' },
    { name: 'CST', offset: 'UTC -5' },
    { name: 'CT', offset: 'UTC -6:00' },
    { name: 'CVT', offset: 'UTC -1' },
    { name: 'CXT', offset: 'UTC +7' },
    { name: 'ChST', offset: 'UTC +10' },
    { name: 'D', offset: 'UTC +4' },
    { name: 'DAVT', offset: 'UTC +7' },
    { name: 'DDUT', offset: 'UTC +10' },
    { name: 'E', offset: 'UTC +5' },
    { name: 'EASST', offset: 'UTC -5' },
    { name: 'EAST', offset: 'UTC -6' },
    { name: 'EAT', offset: 'UTC +3' },
    { name: 'ECT', offset: 'UTC -5' },
    { name: 'EDT', offset: 'UTC -4' },
    { name: 'EEST', offset: 'UTC +3' },
    { name: 'EET', offset: 'UTC +2' },
    { name: 'EGST', offset: 'UTC +0' },
    { name: 'EGT', offset: 'UTC -1' },
    { name: 'EST', offset: 'UTC -5' },
    { name: 'ET', offset: 'UTC -5:00' },
    { name: 'F', offset: 'UTC +6' },
    { name: 'FET', offset: 'UTC +3' },
    { name: 'FJST', offset: 'UTC +13' },
    { name: 'FJT', offset: 'UTC +12' },
    { name: 'FKST', offset: 'UTC -3' },
    { name: 'FKT', offset: 'UTC -4' },
    { name: 'FNT', offset: 'UTC -2' },
    { name: 'G', offset: 'UTC +7' },
    { name: 'GALT', offset: 'UTC -6' },
    { name: 'GAMT', offset: 'UTC -9' },
    { name: 'GET', offset: 'UTC +4' },
    { name: 'GFT', offset: 'UTC -3' },
    { name: 'GILT', offset: 'UTC +12' },
    { name: 'GMT', offset: 'UTC +0' },
    { name: 'GST', offset: 'UTC +4' },
    { name: 'GST', offset: 'UTC -2' },
    { name: 'GYT', offset: 'UTC -4' },
    { name: 'H', offset: 'UTC +8' },
    { name: 'HDT', offset: 'UTC -9' },
    { name: 'HKT', offset: 'UTC +8' },
    { name: 'HOVST', offset: 'UTC +8' },
    { name: 'HOVT', offset: 'UTC +7' },
    { name: 'HST', offset: 'UTC -10' },
    { name: 'I', offset: 'UTC +9' },
    { name: 'ICT', offset: 'UTC +7' },
    { name: 'IDT', offset: 'UTC +3' },
    { name: 'IOT', offset: 'UTC +6' },
    { name: 'IRDT', offset: 'UTC +4:30' },
    { name: 'IRKST', offset: 'UTC +9' },
    { name: 'IRKT', offset: 'UTC +8' },
    { name: 'IRST', offset: 'UTC +3:30' },
    { name: 'IST', offset: 'UTC +5:30' },
    { name: 'IST', offset: 'UTC +1' },
    { name: 'IST', offset: 'UTC +2' },
    { name: 'JST', offset: 'UTC +9' },
    { name: 'K', offset: 'UTC +10' },
    { name: 'KGT', offset: 'UTC +6' },
    { name: 'KOST', offset: 'UTC +11' },
    { name: 'KRAST', offset: 'UTC +8' },
    { name: 'KRAT', offset: 'UTC +7' },
    { name: 'KST', offset: 'UTC +9' },
    { name: 'KUYT', offset: 'UTC +4' },
    { name: 'L', offset: 'UTC +11' },
    { name: 'LHDT', offset: 'UTC +11' },
    { name: 'LHST', offset: 'UTC +10:30' },
    { name: 'LINT', offset: 'UTC +14' },
    { name: 'M', offset: 'UTC +12' },
    { name: 'MAGST', offset: 'UTC +12' },
    { name: 'MAGT', offset: 'UTC +11' },
    { name: 'MART', offset: 'UTC -9:30' },
    { name: 'MAWT', offset: 'UTC +5' },
    { name: 'MDT', offset: 'UTC -6' },
    { name: 'MHT', offset: 'UTC +12' },
    { name: 'MMT', offset: 'UTC +6:30' },
    { name: 'MSD', offset: 'UTC +4' },
    { name: 'MSK', offset: 'UTC +3' },
    { name: 'MST', offset: 'UTC -7' },
    { name: 'MT', offset: 'UTC -7:00' },
    { name: 'MUT', offset: 'UTC +4' },
    { name: 'MVT', offset: 'UTC +5' },
    { name: 'MYT', offset: 'UTC +8' },
    { name: 'N', offset: 'UTC -1' },
    { name: 'NCT', offset: 'UTC +11' },
    { name: 'NDT', offset: 'UTC -2:30' },
    { name: 'NFDT', offset: 'UTC +12' },
    { name: 'NFT', offset: 'UTC +11' },
    { name: 'NOVST', offset: 'UTC +7' },
    { name: 'NOVT', offset: 'UTC +7' },
    { name: 'NPT', offset: 'UTC +5:45' },
    { name: 'NRT', offset: 'UTC +12' },
    { name: 'NST', offset: 'UTC -3:30' },
    { name: 'NUT', offset: 'UTC -11' },
    { name: 'NZDT', offset: 'UTC +13' },
    { name: 'NZST', offset: 'UTC +12' },
    { name: 'O', offset: 'UTC -2' },
    { name: 'OMSST', offset: 'UTC +7' },
    { name: 'OMST', offset: 'UTC +6' },
    { name: 'ORAT', offset: 'UTC +5' },
    { name: 'P', offset: 'UTC -3' },
    { name: 'PDT', offset: 'UTC -7' },
    { name: 'PET', offset: 'UTC -5' },
    { name: 'PETST', offset: 'UTC +12' },
    { name: 'PETT', offset: 'UTC +12' },
    { name: 'PGT', offset: 'UTC +10' },
    { name: 'PHOT', offset: 'UTC +13' },
    { name: 'PHT', offset: 'UTC +8' },
    { name: 'PKT', offset: 'UTC +5' },
    { name: 'PMDT', offset: 'UTC -2' },
    { name: 'PMST', offset: 'UTC -3' },
    { name: 'PONT', offset: 'UTC +11' },
    { name: 'PST', offset: 'UTC -8' },
    { name: 'PST', offset: 'UTC -8' },
    { name: 'PT', offset: 'UTC -8:00' },
    { name: 'PWT', offset: 'UTC +9' },
    { name: 'PYST', offset: 'UTC -3' },
    { name: 'PYT', offset: 'UTC -4' },
    { name: 'PYT', offset: 'UTC +8:30' },
    { name: 'Q', offset: 'UTC -4' },
    { name: 'QYZT', offset: 'UTC +6' },
    { name: 'R', offset: 'UTC -5' },
    { name: 'RET', offset: 'UTC +4' },
    { name: 'ROTT', offset: 'UTC -3' },
    { name: 'S', offset: 'UTC -6' },
    { name: 'SAKT', offset: 'UTC +11' },
    { name: 'SAMT', offset: 'UTC +4' },
    { name: 'SAST', offset: 'UTC +2' },
    { name: 'SBT', offset: 'UTC +11' },
    { name: 'SCT', offset: 'UTC +4' },
    { name: 'SGT', offset: 'UTC +8' },
    { name: 'SRET', offset: 'UTC +11' },
    { name: 'SRT', offset: 'UTC -3' },
    { name: 'SST', offset: 'UTC -11' },
    { name: 'SYOT', offset: 'UTC +3' },
    { name: 'T', offset: 'UTC -7' },
    { name: 'TAHT', offset: 'UTC -10' },
    { name: 'TFT', offset: 'UTC +5' },
    { name: 'TJT', offset: 'UTC +5' },
    { name: 'TKT', offset: 'UTC +13' },
    { name: 'TLT', offset: 'UTC +9' },
    { name: 'TMT', offset: 'UTC +5' },
    { name: 'TOST', offset: 'UTC +14' },
    { name: 'TOT', offset: 'UTC +13' },
    { name: 'TRT', offset: 'UTC +3' },
    { name: 'TVT', offset: 'UTC +12' },
    { name: 'U', offset: 'UTC -8' },
    { name: 'ULAST', offset: 'UTC +9' },
    { name: 'ULAT', offset: 'UTC +8' },
    { name: 'UTC', offset: 'UTC +0' },
    { name: 'UYST', offset: 'UTC -2' },
    { name: 'UYT', offset: 'UTC -3' },
    { name: 'UZT', offset: 'UTC +5' },
    { name: 'V', offset: 'UTC -9' },
    { name: 'VET', offset: 'UTC -4' },
    { name: 'VLAST', offset: 'UTC +11' },
    { name: 'VLAT', offset: 'UTC +10' },
    { name: 'VOST', offset: 'UTC +6' },
    { name: 'VUT', offset: 'UTC +11' },
    { name: 'W', offset: 'UTC -10' },
    { name: 'WAKT', offset: 'UTC +12' },
    { name: 'WARST', offset: 'UTC -3' },
    { name: 'WAST', offset: 'UTC +2' },
    { name: 'WAT', offset: 'UTC +1' },
    { name: 'WEST', offset: 'UTC +1' },
    { name: 'WET', offset: 'UTC +0' },
    { name: 'WFT', offset: 'UTC +12' },
    { name: 'WGST', offset: 'UTC -2' },
    { name: 'WGT', offset: 'UTC -3' },
    { name: 'WIB', offset: 'UTC +7' },
    { name: 'WIT', offset: 'UTC +9' },
    { name: 'WITA', offset: 'UTC +8' },
    { name: 'WST', offset: 'UTC +13' },
    { name: 'WST', offset: 'UTC +1' },
    { name: 'WT', offset: 'UTC +0' },
    { name: 'X', offset: 'UTC -11' },
    { name: 'Y', offset: 'UTC -12' },
    { name: 'YAKST', offset: 'UTC +10' },
    { name: 'YAKT', offset: 'UTC +9' },
    { name: 'YAPT', offset: 'UTC +10' },
    { name: 'YEKST', offset: 'UTC +6' },
    { name: 'YEKT', offset: 'UTC +5' },
    { name: 'Z', offset: 'UTC +0' }
]

/**
 * Modifications to the list below (which was received from Google's Translate API):
 * Removed - (Meitei Mayek) from Manipuri and added a separate entry for the same language with name: "Meitei"
 * Removed - (Oriya) from Odia and added a separate entry for the same language with name: "Oriya"
 * Replaced - Myanmar (Burmese) with Burmese
 * Replaced - Chinese (Simplified) and Chinese (Traditional) with Simplified Chinese and Traditional Chinese, respectively
 * Replaced - Kurdish (Kurmanji) and Kurdish (Sorani) with Kurmanji Kurdish and Sorani Kurdish, respectively
 * Added - fil as a language code for Filipino
 * DO NOT REMOVE ANY ENTRIES, ONLY NAMES CAN BE CHANGED
 */
export let languageCodes = [
    {code:'af', name:'Afrikaans'},
    {code:'ak', name:'Akan'},
    {code:'sq', name:'Albanian'},
    {code:'am', name:'Amharic'},
    {code:'ar', name:'Arabic'},
    {code:'hy', name:'Armenian'},
    {code:'as', name:'Assamese'},
    {code:'ay', name:'Aymara'},
    {code:'az', name:'Azerbaijani'},
    {code:'bm', name:'Bambara'},
    {code:'eu', name:'Basque'},
    {code:'be', name:'Belarusian'},
    {code:'bn', name:'Bengali'},
    {code:'bho', name:'Bhojpuri'},
    {code:'bs', name:'Bosnian'},
    {code:'bg', name:'Bulgarian'},
    {code:'ca', name:'Catalan'},
    {code:'ceb', name:'Cebuano'},
    {code:'ny', name:'Chichewa'},
    {code:'zh', name:'Simplified Chinese'},
    {code:'zh-CN', name:'Simplified Chinese'},
    {code:'zh-TW', name:'Traditional Chinese'},
    {code:'co', name:'Corsican'},
    {code:'hr', name:'Croatian'},
    {code:'cs', name:'Czech'},
    {code:'da', name:'Danish'},
    {code:'dv', name:'Divehi'},
    {code:'doi', name:'Dogri'},
    {code:'nl', name:'Dutch'},
    {code:'en', name:'English'},
    {code:'eo', name:'Esperanto'},
    {code:'et', name:'Estonian'},
    {code:'ee', name:'Ewe'},
    {code:'tl', name:'Filipino'},
    {code:'fil', name:'Filipino'},
    {code:'fi', name:'Finnish'},
    {code:'fr', name:'French'},
    {code:'fy', name:'Frisian'},
    {code:'gl', name:'Galician'},
    {code:'lg', name:'Ganda'},
    {code:'ka', name:'Georgian'},
    {code:'de', name:'German'},
    {code:'gom', name:'Goan Konkani'},
    {code:'el', name:'Greek'},
    {code:'gn', name:'Guarani'},
    {code:'gu', name:'Gujarati'},
    {code:'ht', name:'Haitian Creole'},
    {code:'ha', name:'Hausa'},
    {code:'haw', name:'Hawaiian'},
    {code:'iw', name:'Hebrew'},
    {code:'hi', name:'Hindi'},
    {code:'hmn', name:'Hmong'},
    {code:'hu', name:'Hungarian'},
    {code:'is', name:'Icelandic'},
    {code:'ig', name:'Igbo'},
    {code:'ilo', name:'Iloko'},
    {code:'id', name:'Indonesian'},
    {code:'ga', name:'Irish'},
    {code:'it', name:'Italian'},
    {code:'ja', name:'Japanese'},
    {code:'jw', name:'Javanese'},
    {code:'kn', name:'Kannada'},
    {code:'kk', name:'Kazakh'},
    {code:'km', name:'Khmer'},
    {code:'rw', name:'Kinyarwanda'},
    {code:'ko', name:'Korean'},
    {code:'kri', name:'Krio'},
    {code:'ku', name:'Kurmanji Kurdish'},
    {code:'ckb', name:'Sorani Kurdish'},
    {code:'ky', name:'Kyrgyz'},
    {code:'lo', name:'Lao'},
    {code:'la', name:'Latin'},
    {code:'lv', name:'Latvian'},
    {code:'ln', name:'Lingala'},
    {code:'lt', name:'Lithuanian'},
    {code:'lb', name:'Luxembourgish'},
    {code:'mk', name:'Macedonian'},
    {code:'mai', name:'Maithili'},
    {code:'mg', name:'Malagasy'},
    {code:'ms', name:'Malay'},
    {code:'ml', name:'Malayalam'},
    {code:'mt', name:'Maltese'},
    {code:'mni-Mtei', name:'Manipuri'},
    {code:'mni-Mtei', name:'Meitei'},
    {code:'mi', name:'Maori'},
    {code:'mr', name:'Marathi'},
    {code:'lus', name:'Mizo'},
    {code:'mn', name:'Mongolian'},
    {code:'my', name:'Burmese'},
    {code:'ne', name:'Nepali'},
    {code:'nso', name:'Northern Sotho'},
    {code:'no', name:'Norwegian'},
    {code:'or', name:'Odia'},
    {code:'or', name:'Oriya'},
    {code:'om', name:'Oromo'},
    {code:'ps', name:'Pashto'},
    {code:'fa', name:'Persian'},
    {code:'pl', name:'Polish'},
    {code:'pt', name:'Portuguese'},
    {code:'pa', name:'Punjabi'},
    {code:'qu', name:'Quechua'},
    {code:'ro', name:'Romanian'},
    {code:'ru', name:'Russian'},
    {code:'sm', name:'Samoan'},
    {code:'sa', name:'Sanskrit'},
    {code:'gd', name:'Scots Gaelic'},
    {code:'sr', name:'Serbian'},
    {code:'st', name:'Sesotho'},
    {code:'sn', name:'Shona'},
    {code:'sd', name:'Sindhi'},
    {code:'si', name:'Sinhala'},
    {code:'sk', name:'Slovak'},
    {code:'sl', name:'Slovenian'},
    {code:'so', name:'Somali'},
    {code:'es', name:'Spanish'},
    {code:'su', name:'Sundanese'},
    {code:'sw', name:'Swahili'},
    {code:'sv', name:'Swedish'},
    {code:'tg', name:'Tajik'},
    {code:'ta', name:'Tamil'},
    {code:'tt', name:'Tatar'},
    {code:'te', name:'Telugu'},
    {code:'th', name:'Thai'},
    {code:'ti', name:'Tigrinya'},
    {code:'ts', name:'Tsonga'},
    {code:'tr', name:'Turkish'},
    {code:'tk', name:'Turkmen'},
    {code:'uk', name:'Ukrainian'},
    {code:'ur', name:'Urdu'},
    {code:'ug', name:'Uyghur'},
    {code:'uz', name:'Uzbek'},
    {code:'vi', name:'Vietnamese'},
    {code:'cy', name:'Welsh'},
    {code:'xh', name:'Xhosa'},
    {code:'yi', name:'Yiddish'},
    {code:'yo', name:'Yoruba'},
    {code:'zu', name:'Zulu'},
    {code:'he', name:'Hebrew'},
]

export let TZdefault = timeZoneOffsets.find(TZ => TZ.name === 'EST')! //Set the default timezone to use for functions

/**
 * Converts UTC offset in format ±hours:minutes to minutes
 * @param {String} offset - The UTC offset in format ±hours:minutes 
 */
export function parseOffset(offset: string){
    let hours = parseInt(offset.match(/-?\d+/)![0])
    let minutes = /:\d+/.test(offset) ? parseInt(offset.match(/(?<=:)\d+/)![0]) : 0
    return hours * 60 + minutes
}

/**
 * Returns a time zone offset object with time zone name and offset. Defaults to UTC+0 if input is invalid.
 */
export let findTimeZone = (timeZone: string) => timeZoneOffsets.find(TZ => TZ.name === timeZone.toUpperCase()) || TZdefault

/**
 * Returns the last word in a string
 */
export let findLastWord = (string: string) => string.trim().split(' ').pop() || ''

/**
 * Capitalizes the first letter of every word in a string
 */
export let capitalize = (string: string) => string.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')

/**
 * Capitalizes the first letter in a string
 */
export let capFirstLetter = (string: string) => string.charAt(0).toUpperCase() + string.slice(1)

/**
 * Formats an array of strings by inserting commas and replacing the last comma with ", and".
 */
export function formatList(array: string[]){
    let formattedList = array.join(', ')
    formattedList = formattedList.replace(/(.+)\,(\s*)(.+$)/, '$1$2and $3')
    return formattedList
}

/**
 * Takes a string containing an abbreviated number and converts it to an actual number. (Ex: 1k = 1,000)
 */
export function getNumber(num: string){
    if (!/\d/.test(num)) return 0
    const number = parseFloat(num.match(/[\d.]+/)![0])
    const abbreviation = String(num.match(/k|m|b|t/i)).toLowerCase()

    switch (abbreviation) {
        case 't': return Math.round(number * 1e12)
        case 'b': return Math.round(number * 1e9)
        case 'm': return Math.round(number * 1e6)
        case 'k': return Math.round(number * 1e3)
        default : return Math.round(number)
    }
}

/**
 * Takes a number and returns it in an abbreviated form. (Ex: 1,000 = 1k)
 */
export function getAbbreviatedNumber(num: number){
    if (num >= 1e12) return `${parseFloat((num /= 1e12).toFixed(2))}t`
    else if (num >= 1e9) return `${parseFloat((num /= 1e9).toFixed(2))}b`
    else if (num >= 1e6) return `${parseFloat((num /= 1e6).toFixed(2))}m`
    else if (num >= 1e3) return `${parseFloat((num /= 1e3).toFixed(2))}k`
    else return String(num)
}

/**
 * Replaces all numbers in a string with their abbreviated versions.
 */
export function abbreviateAllNumbers(string: string){
    const numbers = string.match(/[\d.]+/g)
    if (!numbers) return string
    numbers.forEach(number => {
        string = string.replace(number, getAbbreviatedNumber(getNumber(number)))
    })
    return string
}

import axios from 'axios'
/**
 * Takes an Imgur link and returns a list of direct image links. Works with Albums and Galleries.
 * @param url An Imgur link
 * @returns Array of direct image links
 */
export async function getDirectImgurLinks(url: string): Promise<string[]> {
    if (url.includes('i.imgur.com') || !url.includes('imgur.com')) return [url]
    if (/(imgur\.)(com\/gallery\/|com\/a\/|com\/t\/.+?\/)/.test(url)) {
        const albumHash = url.match(/(?:com\/gallery\/|com\/a\/|com\/t\/.+?\/)(.+)/)![1]
        const {data: {data}} = await axios.get(`https://api.imgur.com/3/album/${albumHash}/images`, {headers: {Authorization: `Client-ID ${process.env.IMGUR_CLIENT_ID}`}})
        return data.map((img: any) => img.link)
    } else {
        const imageHash = url.match(/(?<=com\/).+/)
        const {data: {data}} = await axios.get(`https://api.imgur.com/3/image/${imageHash}`, {headers: {Authorization: `Client-ID ${process.env.IMGUR_CLIENT_ID}`}})
        return [data.link]
    }
}

/**
 * Returns the difference between 2 dates (secondDate - firstDate) as a string in the following format: days, hours, minutes, and seconds.
 * @param {boolean} shortFormat - Whether to use the shorthand format (d h m s instead of days, hours, minutes, and seconds)
 */
export function dateDiff(firstDate: Date, secondDate: Date, shortFormat: boolean = false) {
    if (firstDate === secondDate) {return 'right now'}
    let timeDiff = Math.abs(secondDate.getTime() - firstDate.getTime()) / 1000 //Gets difference between the dates in seconds

    //Calculates difference of days, hours, minutes, seconds
    let days = Math.floor(timeDiff / 86400)
    timeDiff -= days * 86400
    let hours = Math.floor(timeDiff / 3600)
    timeDiff -= hours * 3600
    let minutes = Math.floor(timeDiff / 60)
    timeDiff -= minutes * 60
    let seconds = Math.floor(timeDiff)

    //Labels days, hours, minutes, seconds grammatically and leaves blank when appropriate
    let daysOutput = days === 1 ? `${days} day,` : days ? `${days} days,` : ''
    let hoursOutput = hours === 1 ? `${hours} hour,` : hours ? `${hours} hours,` : ''
    let minutesOutput = minutes === 1 ? `${minutes} minute,` : minutes ? `${minutes} minutes,` : ''
    let secondsOutput = seconds === 1 ? `${seconds} second,` : seconds ? `${seconds} seconds,` : ''
    let dateString = `${daysOutput} ${hoursOutput} ${minutesOutput} ${secondsOutput}`
        .replace(/,(?=[^,]*$)/, '') //removes extra comma at the end of the string
        .replace(/,(?=[^,]*$)/, ' and') //replaces last comma in string with "and"
    if (shortFormat) dateString = dateString.replace(/\sdays?/, 'd').replace(/\shours?/, 'h').replace(/\sminutes?/, 'm').replace(/\sseconds?/, 's').replace(/\sand/, '').replace(/,/g, '')
    return secondDate > firstDate ? dateString.trim() : `-${dateString.trim()}` //Removes extra whitespace from both ends, make time negative if applicable
}

/**
 * Converts time duration input to unix. Format: a days b hours c minutes d seconds.
 */
export function timeToUnix(time: string) { //Converts a day/hour/minute/second time input to unix
    let days = /\d+\s?d/i.test(time) ? parseInt(time.match(/\d+\s?d/i)![0]) : (/\sd/i.test(time) || /^d/i.test(time)) ? 1 : 0
    let hours = /\d+\s?h/i.test(time) ? parseInt(time.match(/\d+\s?h/i)![0]) : (/\sh/i.test(time) || /^h/i.test(time)) ? 1 : 0
    let minutes = /\d+\s?m/i.test(time) ? parseInt(time.match(/\d+\s?m/i)![0]) : (/\sm/i.test(time) || /^m/i.test(time)) ? 1 : 0
    let seconds = /\d+\s?s/i.test(time) ? parseInt(time.match(/\d+\s?s/i)![0]) : (/\ss/i.test(time) || /^s/i.test(time)) ? 1 : 0
    return days * 86400000 + hours * 3600000 + minutes * 60000 + seconds * 1000
}

/**
 * Converts date/time input to unix. Format: 1:23 AM/PM TimeZone
 */
export function dateStringToUnix(dateString: string) {
    dateString = dateString.toLowerCase().replace(/[^a-zA-Z0-9\s\/:]/g, '') //Remove any characters that aren't words/numbers/spaces/slashes
    let now = new Date()
    let year = now.getFullYear().toString()
    let months = [ 'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec' ]
    let month = months.find(m => dateString.toLowerCase().includes(m))
    let timeFormat = new RegExp(/(\d+\s*:\s*\d+\s*:?\s*\d*\s*(AM|PM)?)|(\d+\s*(AM|PM))/i)
    let abbreviated = new RegExp('(\\d\\d?)\\s*/\\s*(\\d\\d?)\\s*/?\\s*(\\d*)') // 1/1/1970
    let american = new RegExp(`(${month}\\w*)\\s+(\\d+)(?:\\w*)\\s*(\\d*)`) // January 1, 1970
    let british = new RegExp(`(\\d+)(?:\\w*)\\s*(${month}\\w*)\\s*(\\d*)`) // 1 January, 1970
    let mdyTimeZones = ['sst', 'pdt', 'pst', 'pt', 'ndt', 'nst', 'adt', 'ast', 'at', 'est', 'edt', 'et', 'cst', 'cdt', 'ct', 'mst', 'mdt', 'mt', 'chut', 'pont', 'kost', 'chst', 'jst', 'kst', 'mht', 'pht', 'aoe', 'wakt', 'hst', 'akdt'] //Timezones that use the Month/Day/Year format
    let date = '', time = dateString.match(timeFormat)![0], timeZone = TZdefault.name

    if (time) { //Extracts the time, if it was provided
        dateString = dateString.replace(timeFormat, '').trim() //Remove the time from dateString
        if (time.match(/\d+/)![0] !== '12' && /pm/i.test(time)) {time = time.replace(/\d+/, String(parseInt(time.match(/\d+/)![0]) + 12))} //Convert the time input to military time
        time = time.replace(/\s*(am|pm)/i, '') //Remove AM or PM from the time input   
        while (!/.+:.+:.+/.test(time)) {time += ':00'} //Coerce time input to format hh:mm:ss (hours, minutes, and seconds)
    }

    let dateData: RegExpMatchArray = []
    let getDateData = (format: RegExp) => {
        if (dateString.replace(format, '').trim()) {timeZone = dateString.replace(format, '').trim().split(' ').at(-1)!} //Note the time zone if it was provided
        dateData = dateString.match(format)!
        if (!dateData[3]) {dateData[3] = year}
    }

    if (abbreviated.test(dateString)) { //Abbreviated date format
        getDateData(abbreviated)
        if (mdyTimeZones.some((e) => e === timeZone)) {
            date = `${dateData[1]}/${dateData[2]}/${dateData[3]}`
        } else {
            date = `${dateData[2]}/${dateData[1]}/${dateData[3]}`
        }
    } else if (american.test(dateString)) { //American date format
        getDateData(american)
        date = `${dateData[1]} ${dateData[2]} ${dateData[3]}`
    } else if (british.test(dateString)) { //British date format
        getDateData(british)
        date = `${dateData[2]} ${dateData[1]} ${dateData[3]}`
    } else if (time) { //If a date wasn't specified, use today's date
        if (dateString) {timeZone = dateString.trim().split(' ').at(-1)!}
        let timeZoneOffset = findTimeZone(timeZone).offset
        now.setHours(new Date().getHours() + parseInt(timeZoneOffset.match(/-?\d+/)![0]))
        date = `${now.getMonth() + 1}/${now.getDate()}/${year}`
    } else {
        return null
    }

    let timeZoneOffset = findTimeZone(timeZone).offset
    return isNaN(Date.parse(`${date} ${time} ${timeZoneOffset}`)) ? Date.parse(`${date} ${time}`) : Date.parse(`${date} ${time} ${timeZoneOffset}`)
}

/**
 * Converts a Date object to a more readable format - [Thu Jan 1 1970 00:00:00 AM]
 * @param {Boolean} showTZ - Whether or not the time zone should be displayed
 */
export function dateToString(date: Date, timeZone: string = 'UTC', showTZ: boolean = false) {
    date.setMinutes(date.getMinutes() + new Date().getTimezoneOffset()) //Ensures that the function uses UTC rather than the system timezone. Unecessary in if host uses UTC.
    date.setMinutes(date.getMinutes() + parseOffset(findTimeZone(timeZone).offset)) //Add the offset from UTC to the date
    let dateString = String(date).replace(/\sGMT.\d{4}\s\(.+\)/, '') //Removes the timezone offset in GMT from the date string
    let hours = parseInt(dateString.match(/\d\d:/)![0])
    let ampm = hours < 12 ? 'AM' : 'PM'

    if (hours > 12) {dateString = dateString.replace(`${hours}:`, `${hours - 12}:`)} //Coerce the output to 12 hour format
    if (hours === 0) {dateString = dateString.replace(`${hours}:`, `${hours + 12}:`)} //Coerce the output to 12 hour format
    if (!showTZ) {timeZone = ''}
    return `${dateString} ${ampm} ${timeZone.toUpperCase()}`.trim()
}

/**
 * Writes text that wraps around when it reaches a horizontal limit
 * @param ctx - The Canvas API
 * @param text - The text to be written
 * @param alignment - The alignment of the text (left, right, center)
 * @param font - The font of the text
 * @param outline - The color for the outline of the text
 * @param color - The color of the text
 * @param textX - The X coordinate of the text
 * @param textY - The Y coordinate of the text
 * @param maxWidth - The width of the line of text. After reaching this width limit the text will wrap around
 * @param lineHeight - The spacing between lines of text
 */
export function wrapText(ctx: CanvasRenderingContext2D, text: string, alignment: CanvasTextAlign, font: string, outline: string, color: string, textX: number, textY: number, maxWidth: number, lineHeight: number) { // For drawing event titles
    ctx.font = font
    ctx.textAlign = alignment
    ctx.strokeStyle = outline
    ctx.lineWidth = 3
    ctx.fillStyle = color
    ctx.textBaseline = 'middle'
    let words = text.split(' ')
    let line = ''
    
    for (let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' '
        let metrics = ctx.measureText(testLine)
        let testWidth = metrics.width
        if (testWidth > maxWidth && n > 0) {
            // textY -= 20
            textY -= (ctx.measureText(text).actualBoundingBoxAscent + ctx.measureText(text).actualBoundingBoxDescent) / 2
            ctx.strokeText(line, textX, textY)
            ctx.fillText(line, textX, textY)
            line = words[n] + ' '
            textY += lineHeight
        } else {
            line = testLine
        }
    }
    ctx.strokeText(line, textX, textY)
    ctx.fillText(line, textX, textY)
}

/**
 * Draws centered text
 * @param ctx - The Canvas API
 * @param text - The text to be written
 * @param font - The font of the text
 * @param outline - The color for the outline of the text
 * @param color - The color of the text
 * @param x - The x coordinate of the text
 * @param y - The y coordinate of the text
 */
export function drawCentered(ctx: CanvasRenderingContext2D, text: string, font: string, outline: string, color: string, x: number, y: number) { // For drawing event durations
    ctx.font = font
    ctx.textAlign = 'center'
    ctx.strokeStyle = outline
    ctx.lineWidth = 3
    ctx.strokeText(text, x, y)
    ctx.fillStyle = color
    ctx.fillText(text, x, y)
}